#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/netmgr.h>
#include <sys/neutrino.h>
#include <errno.h>
#include <sched.h>
#include <pthread.h>
#include "../../states.h"
#include "../../shared_data_structures.h"

#define RAIL_CROSSING_NAME "X1"
#define RAIL_TIMER_PULSE_CODE _PULSE_CODE_MINAVAIL
#define POLL_TIMER_PULSE_CODE _PULSE_CODE_MINAVAIL

#define DEFAULT_RED_TIMING 10;
#define DEFAULT_POLL_TIMING_NS 500000000;

#define RAIL_I_EAST_NORTH 0
#define RAIL_I_WEST_NORTH 1
#define RAIL_I_EAST_SOUTH 2
#define RAIL_I_WEST_SOUTH 3

#define RAIL_O_EAST_NORTH 0
#define RAIL_O_WEST_NORTH 1
#define RAIL_O_EAST_SOUTH 2
#define RAIL_O_WEST_SOUTH 3
/*
 * Sensors stuff
 */
#include <hw/inout.h>      // for in32() and out32();
#include <sys/mman.h>      // for mmap_device_io();
#include <stdint.h>		   // for unit32 types
#include <string.h>
#include <sys/procmgr.h>

#define PIO_SIZE			0x0000001F
#define PIO_SIZE_Switches	0x0000000F
#define LEDs_BASE			0xFF200000  //(LEDs - 8 bits wide - output only)
#define GPIO_1_BASE			0xFF200020  //(GPIO_1 - JP7 header - 16 bits wide - Input only)
#define GPIO_0_BASE			0xFF200040  //(GPIO_0 - JP1 header - 16 bits wide - Output only)
#define SWITCHES_BASE		0xFF200060  //(Switches - 4 bits wide - Inputs only)

struct s_io_id
{
	uintptr_t gpio_LEDs;
	uintptr_t gpio_0_outputs;
	uintptr_t gpio_1_inputs;
	uintptr_t Switches_inputs;
};

struct s_rail_data
{
	struct s_rail_message_data message_data;
	pthread_rwlock_t rwlock;
};

struct s_signal_msg
{
	struct _pulse pulse;
};

struct s_rail_timing_event
{
	struct sigevent rail_timer_event;
	struct itimerspec instant_timer_spec;
	struct itimerspec red_timer_spec;
	timer_t timer_id;
	int channel_id;
	int receive_id;
	struct s_signal_msg msg;

	struct sigevent poll_timer_event;
	struct itimerspec poll_timer_spec;
	timer_t poll_timer_id;
	int poll_channel_id;
	int poll_receive_id;
	struct s_signal_msg poll_msg;
};

struct s_rail_control
{
	struct s_rail_timing_event rail_timing;
	struct s_rail_data rail_data;
	struct s_io_id io_id;
};

void initialiseRailCrossingData(struct s_rail_data *rdata);
int initialiseTimers(struct s_rail_timing_event *timing_data);
void *railCrossingControl(void* rail_control_data);
void railOverrideHandler(struct s_rail_data *rdata);
void updateLights(struct s_rail_control *rdata);
void* sensorPoll(void *data);
void printRailState(enum e_STATE state);


int initIO(struct s_rail_control *data);
void unmapIO(struct s_rail_control *data);

int main(void)
{

	// Puts it all in one nice neat struct for the thread stuff.
	struct s_rail_control  rail_control_data;
	/*
	 * These structure will be updated as sensor values are updated.
	 *	Initialises all of the traffic data to initial values.	 *
	 */

	//struct s_rail_data rail_data;
	initialiseRailCrossingData(&rail_control_data.rail_data);
	/*
	 * This holds all the timing event and signals for he traffic light.
	 * The following code initialises all of the timing and signal stuff.
	 */

	//struct s_traffic_timing_event traffic_timing;
	if(initialiseTimers(&rail_control_data.rail_timing) < 0)
	{
		perror (NULL);
		exit (EXIT_FAILURE);
	}

	if(!initIO(&rail_control_data))
	{
		puts("Failed to initiate IO, exiting main...");
		return EXIT_SUCCESS;
	}


	// Creates thread and thread attributes for traffic lights
	pthread_t  rail_control_thread;
	pthread_attr_t rail_control_thread_attr;
	struct sched_param rail_control_thread_param;
	pthread_attr_init(&rail_control_thread_attr);
	rail_control_thread_param.sched_priority = 10;
	pthread_attr_setschedparam(&rail_control_thread_attr, &rail_control_thread_param);

	// Creates thread and thread attributes for polling
	pthread_t  poll_thread;
	pthread_attr_t poll_thread_attr;
	struct sched_param poll_thread_param;
	pthread_attr_init(&poll_thread_attr);
	poll_thread_param.sched_priority = 5;
	pthread_attr_setschedparam(&poll_thread_attr, &poll_thread_param);

	// Starts traffic light control thread.
	pthread_create(&rail_control_thread, &rail_control_thread_attr, railCrossingControl, &rail_control_data);
	// starts poll thread.
	pthread_create(&poll_thread, &poll_thread_attr, sensorPoll, &rail_control_data);

	void* ret;
	pthread_join(rail_control_thread, &ret);

	return EXIT_SUCCESS;
}

void initialiseRailCrossingData(struct s_rail_data *rdata)
{
	struct s_rail_data *rail_data = (struct s_rail_data*) rdata;

	rail_data->message_data.lights_red_length = 10;

	rail_data->message_data.override_active_flag = 0;
	rail_data->message_data.override_new_state = RAIL_ERROR;

	rail_data->message_data.train_present_flag = NOT_PRESENT;
	rail_data->message_data.current_state = GATE_CLOSED_INIT;

	rail_data->message_data.east_north_train_sensor = INACTIVE;
	rail_data->message_data.east_south_train_sensor = INACTIVE;
	rail_data->message_data.west_north_train_sensor = INACTIVE;
	rail_data->message_data.west_south_train_sensor = INACTIVE;
}


int initialiseTimers(struct s_rail_timing_event *timing_data)
{
	struct s_rail_timing_event *rail_timing = (struct s_rail_timing_event*) timing_data;
	// Creates communication channel
	rail_timing->channel_id = ChannelCreate(0);
	rail_timing->poll_channel_id = ChannelCreate(0);
	rail_timing->rail_timer_event.sigev_notify = SIGEV_PULSE;
	rail_timing->poll_timer_event.sigev_notify = SIGEV_PULSE;
	// create a connection back to ourselves for the timer to send the pulse on
	rail_timing->rail_timer_event.sigev_coid = ConnectAttach(ND_LOCAL_NODE, 0, rail_timing->channel_id, _NTO_SIDE_CHANNEL, 0);
	rail_timing->poll_timer_event.sigev_coid = ConnectAttach(ND_LOCAL_NODE, 0, rail_timing->poll_channel_id, _NTO_SIDE_CHANNEL, 0);
	if(rail_timing->rail_timer_event.sigev_coid == -1)
	{
	   printf("%s:  rail timing couldn't ConnectAttach to self!\n", RAIL_CROSSING_NAME);
	   return -1;
	}

	if(rail_timing->poll_timer_event.sigev_coid == -1)
	{
	   printf("%s:  poll timing couldn't ConnectAttach to self!\n", RAIL_CROSSING_NAME);
	   return -1;
	}
		// The following line might be needed?
	//event.sigev_priority = getprio(0);
	rail_timing->rail_timer_event.sigev_code = RAIL_TIMER_PULSE_CODE;
	rail_timing->poll_timer_event.sigev_code = POLL_TIMER_PULSE_CODE;
	//create the timer, binding it to the event
	if(timer_create(CLOCK_REALTIME, &rail_timing->rail_timer_event, &rail_timing->timer_id) == -1)
	{
	   printf("%s:  couldn't create a rail timer\n", RAIL_CROSSING_NAME);
	   return -1;
	}

	if(timer_create(CLOCK_REALTIME, &rail_timing->poll_timer_event, &rail_timing->poll_timer_id) == -1)
	{
	   printf("%s:  couldn't create a poll timer\n", RAIL_CROSSING_NAME);
	   return -1;
	}

	rail_timing->red_timer_spec.it_value.tv_sec = DEFAULT_RED_TIMING;
	rail_timing->red_timer_spec.it_value.tv_nsec = 0;
	rail_timing->red_timer_spec.it_interval.tv_sec = DEFAULT_RED_TIMING;
	rail_timing->red_timer_spec.it_interval.tv_nsec = 0;


	rail_timing->instant_timer_spec.it_value.tv_sec = 0;
	rail_timing->instant_timer_spec.it_value.tv_nsec = 1000;
	rail_timing->instant_timer_spec.it_interval.tv_sec = 0;
	rail_timing->instant_timer_spec.it_interval.tv_nsec = 1000;

	rail_timing->poll_timer_spec.it_value.tv_sec = 0;
	rail_timing->poll_timer_spec.it_value.tv_nsec = DEFAULT_POLL_TIMING_NS;
	rail_timing->poll_timer_spec.it_interval.tv_sec = 0;
	rail_timing->poll_timer_spec.it_interval.tv_nsec = DEFAULT_POLL_TIMING_NS;
	return 0;
}

void startTimer(timer_t timer, struct itimerspec spec)
{
	timer_settime(timer, 0, &spec, NULL);
}

void *railCrossingControl(void *data)
{
	struct s_rail_control *rail_control_data = (struct s_rail_control*) data;
	struct s_rail_data *rail_data = &rail_control_data->rail_data;
	struct s_rail_timing_event *timing_data = &rail_control_data->rail_timing;
	// Do first timer.
	startTimer(timing_data->timer_id, timing_data->instant_timer_spec);
	puts("railCrossingControl: first timer started");
	while(1)
	{

		// Wait for for message timing pulse
		timing_data->receive_id = MsgReceive(timing_data->channel_id, &timing_data->msg, sizeof(timing_data->msg), NULL);

		// Test if the message came from this process
		if(timing_data->receive_id == 0)
		{
			// Check we got a pulse
			if(timing_data->msg.pulse.code == RAIL_TIMER_PULSE_CODE)
			{
				// All is good. We can try and calculate the traffic
				// lights now.
				pthread_rwlock_rdlock(&rail_data->rwlock);
				pthread_rwlock_rdlock(&rail_data->rwlock);
				updateLights(rail_control_data);
				/*
				 *	Handles a central control override situation.
				 */
				if(rail_data->message_data.override_active_flag)
				{
					puts("railCrossingControl: Central overide detected");
					railOverrideHandler(&rail_control_data->rail_data);
				}
				else if(rail_data->message_data.train_present_flag == PRESENT)
				{
					rail_data->message_data.current_state = GATE_CLOSED;
				}
				else
				{
					switch(rail_data->message_data.current_state)
					{
						case GATE_CLOSED_INIT:
						{
							rail_data->message_data.current_state = GATE_CLOSED;
							//Sets timer to instantly call an output state update.
							startTimer(timing_data->timer_id, timing_data->instant_timer_spec);
							break;
						}
						case GATE_OPEN:
						{
							/*
							 * 	Handles if train is coming and boom gates are closed.
							 */
							if(rail_data->message_data.train_present_flag == NOT_PRESENT)
							{
								rail_data->message_data.current_state = GATE_OPEN;
								break;
							}

							startTimer(timing_data->timer_id, timing_data->red_timer_spec);
							break;
						}
						case GATE_CLOSED:
						{
							if(rail_data->message_data.train_present_flag == NOT_PRESENT)
							{
								rail_data->message_data.current_state = GATE_OPEN;
							}
							break;
						}
						case RAIL_ERROR:
						{
							rail_data->message_data.current_state = GATE_CLOSED;
							break;
						}
						default:
						{
							break;
						}
					}
				}
				pthread_rwlock_unlock(&rail_data->rwlock);
			}
		}
	}
}

void railOverrideHandler(struct s_rail_data *tdata)
{
	struct s_rail_data *rail_data = (struct s_rail_data*) tdata;
	switch(rail_data->message_data.override_new_state)
	{
		case GATE_CLOSED:
		{
			rail_data->message_data.current_state = GATE_CLOSED;
			break;
		}
		case GATE_OPEN:
		{
			rail_data->message_data.current_state = GATE_OPEN;
			break;
		}
		default:
		{
			break;
		}
	}
}

void updateLights(struct s_rail_control *tdata)
{
	struct s_rail_control *rail_control_data = (struct s_rail_control*) tdata;
	struct s_rail_data *rail_data = &rail_control_data->rail_data;
	struct s_io_id *io_id = &rail_control_data->io_id;
	volatile uint32_t	led = 0;
	switch(rail_data->message_data.current_state)
	{
		case GATE_CLOSED_INIT:
		{
			led |= (1<<RAIL_O_EAST_NORTH) | (1<<RAIL_O_WEST_NORTH) | (1<<RAIL_O_EAST_SOUTH) | (1<<RAIL_O_WEST_SOUTH);
			break;
		}
		case GATE_OPEN:
		{
			led = 0;
			break;
		}
		case GATE_CLOSED:
		{
			led |= (1<<RAIL_O_EAST_NORTH) | (1<<RAIL_O_WEST_NORTH) | (1<<RAIL_O_EAST_SOUTH) | (1<<RAIL_O_WEST_SOUTH);
			break;
		}
		case RAIL_ERROR:
		{
			led |= (1<<RAIL_O_EAST_NORTH) | (1<<RAIL_O_WEST_NORTH) | (1<<RAIL_O_EAST_SOUTH) | (1<<RAIL_O_WEST_SOUTH);
			break;
		}
		default:
		{
			break;
		}
	}

	puts("Current State: ");
	printState(rail_data->message_data.current_state);
	out32(io_id->gpio_LEDs,led);
//	printf("output = %#04X\n\n",output);
//	out32(io_id->gpio_0_outputs, output);

}

void* sensorPoll(void *data)
{
	struct s_rail_control *rail_control_data = (struct s_rail_control*) data;
	struct s_rail_data *rail_data = &rail_control_data->rail_data;
	struct s_rail_timing_event *timing_data = &rail_control_data->rail_timing;
	struct s_io_id *io_id = &rail_control_data->io_id;
	volatile uint32_t	inputs = 0;
	volatile uint32_t	switches = 0;


	// start first timer.
	startTimer(timing_data->poll_timer_id, timing_data->poll_timer_spec);

	while(1)
	{
		// Wait for polling timer.
		timing_data->poll_receive_id = MsgReceive(timing_data->poll_channel_id, &timing_data->poll_msg, sizeof(timing_data->poll_msg), NULL);
		// Make sure it is the correct id.
		if(timing_data->poll_receive_id == 0)
		{
			// Check we got a pulse
			if(timing_data->poll_msg.pulse.code == POLL_TIMER_PULSE_CODE)
			{
				// All is good. We can try and get the sensor values you.
				pthread_rwlock_rdlock(&rail_data->rwlock);

			 	switches  = in32(io_id->Switches_inputs);
			 	rail_data->message_data.train_present_flag = NOT_PRESENT;

			 	if((switches >> RAIL_I_EAST_NORTH) & 1)
				{
			 		puts("Train east north sensor active");
			 		rail_data->message_data.east_north_train_sensor = ACTIVE;
			 		rail_data->message_data.train_present_flag = PRESENT;
			 	}
			 	if((switches >> RAIL_I_EAST_SOUTH) & 1)
			 	{
			 		puts("Train east south sensor active");
			 		rail_data->message_data.east_south_train_sensor = ACTIVE;
			 		rail_data->message_data.train_present_flag = PRESENT;
			 	}
			 	if((switches >> RAIL_I_WEST_NORTH) & 1)
				{
					puts("Train west north sensor active");
					rail_data->message_data.west_north_train_sensor = ACTIVE;
					rail_data->message_data.train_present_flag = PRESENT;
				}
			 	if((switches >> RAIL_I_WEST_SOUTH) & 1)
				{
					puts("Train west south sensor active");
					rail_data->message_data.west_south_train_sensor = ACTIVE;
					rail_data->message_data.train_present_flag = PRESENT;
				}

				pthread_rwlock_unlock(&rail_data->rwlock);
				//sleep(1);
				startTimer(timing_data->poll_timer_id, timing_data->poll_timer_spec);
			}
		}
	}
}

int initIO(struct s_rail_control *data)
{
	struct s_rail_control *rail_control_data = (struct s_rail_control*) data;
	struct s_io_id *io_id = &rail_control_data->io_id;

	io_id->gpio_LEDs = mmap_device_io(PIO_SIZE, LEDs_BASE);
	if( !io_id->gpio_LEDs )
	{
		// An error has occurred
		perror("Can't map Control Base Module / gpio_LEDs");
		printf("Mapping IO ERROR! Main Terminated...!\n");
		return 0;
	}

	io_id->Switches_inputs = mmap_device_io(PIO_SIZE_Switches, SWITCHES_BASE);
	if( !io_id->Switches_inputs )
	{
		// An error has occurred
		perror("Can't map Control Base Module / Switches_inputs");
		printf("Mapping IO ERROR! Main Terminated...!\n");
		return 0;
	}
	return 1;
}

void unmapIO(struct s_rail_control *data)
{
	struct s_rail_control *rail_control_data = (struct s_rail_control*) data;
	struct s_io_id *io_id = &rail_control_data->io_id;

	munmap_device_io(io_id->gpio_LEDs, PIO_SIZE);
	munmap_device_io(io_id->Switches_inputs, PIO_SIZE_Switches);
}

void printRailState(enum e_STATE state);
{
	switch(state)
	{
		case EWR_NSR_INIT:
		{
			puts("EWR_NSR_INIT");
			break;
		}
		case EWR_NSR:
		{
			puts("EWR_NSR");
			break;
		}
		case EWG_NSR:
		{
			puts("EWG_NSR");
			break;
		}
		case EWR_NSG:
		{
			puts("EWR_NSG");
			break;
		}
		case EWY_NSR:
		{
			puts("EWY_NSR");
			break;
		}
		case EWR_NSY:
		{
			puts("EWR_NSY");
			break;
		}
		case TRAFFIC_ERROR:
		{
			puts("TRAFFIC_ERROR");
			break;
		}
		case GATE_CLOSED_INIT:
		{
			puts("GATE_CLOSED_INIT");
			break;
		}
		case GATE_OPEN:
		{
			puts("GATE_OPEN");
			break;
		}
		case GATE_CLOSED:
		{
			puts("GATE_CLOSED");
			break;
		}
		case RAIL_ERROR:
		{
			puts("RAIL_ERROR");
			break;
		}
	}
}


